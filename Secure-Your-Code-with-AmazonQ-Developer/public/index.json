[
{
	"uri": "//localhost:1313/1-open-redirect-vulnerability/",
	"title": "Open Redirect Vulnerability",
	"tags": [],
	"description": "",
	"content": "Open Redirect Vulnerability is an security weakness where an attacker could supply a malicious URL as an input, potentially leading users to phishing or malware sites. This is a common security flaw in web applications that can be exploited to conduct phishing attacks or distribute malware.\nFirst, create a folder. Then, create a .py file inside it and paste the code into the file.\nfrom flask import app\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url_noncompliant():\rfrom flask import request, redirect\rendpoint = request.args[\u0026#39;url\u0026#39;]\r# Noncompliant: redirect to a user-supplied URL without sanitization.\rreturn redirect(endpoint) Click on Amazon Q in the status bar and run Project Scan to see how the Open Redirect Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: To fix the open redirect issue in the provided code snippet, you should validate and/or sanitize the URL before performing the redirection. For example, only allow redirects to known, safe domains by checking the user-supplied URL against a whitelist.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\nfrom flask import Flask, request, redirect, url_for\rapp = Flask(__name__)\rALLOWED_HOSTS = [\u0026#39;www.example.com\u0026#39;, \u0026#39;example.org\u0026#39;]\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url():\rfrom urllib.parse import urlparse\r# Retrieve the URL from request arguments and parse it\ruser_url = request.args.get(\u0026#39;url\u0026#39;, \u0026#39;\u0026#39;)\rparsed_url = urlparse(user_url)\r# Check if the URL\u0026#39;s host is in the list of allowed hosts\rif parsed_url.netloc in ALLOWED_HOSTS:\rreturn redirect(user_url)\relse:\r# Redirect to a default page or show an error\rreturn redirect(url_for(\u0026#39;index\u0026#39;)) # Assume \u0026#39;index\u0026#39; is a valid endpoint Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/",
	"title": "Securing Your Code With Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "Securing Your Code With Amazon Q Developer Amazon Q can scan your codebase for security vulnerabilities and code quality issues to improve the posture of your applications throughout the development cycle. You can initiate a scan of an entire codebase, analyzing all files in your local project or workspace, or enable auto scans that assess your code as you write it.\nThis helps your applications to be more secure and resilient by highlighting security issues such as cross-site scripting vulnerabilities, log injections, loose file permissions, hardcoded credentials and more. The earlier security issues are detected, the less work and effort is required to fix the same.\nScan are powered by Security Detectors from the Amazon CodeGuru Detector Library. As security policies are updated and detectors are added, scans automatically incorporate new detectors to ensure your code is compliant with the most up-to-date policies.\nAmazon Q Developer detects security policy violations and vulnerabilities in your code with static application security testing (SAST), secrets detection, and infrastructure as code (IaC) scanning. Security issues found during the scan are highlighted in the Problems panel in VS Code.\nIn this section, we will use the Security Scanning features of Q Developer to detect insecure code.\nThis module deliberately includes code fragments that will trigger security scan findings. Code fragments in this module should only be used for demonstration purposes.\nAmazon Q can scan your entire codebase, or auto-scan your code as you write it. For the purposes of this workshop we will be using project based scanning. Upto 100 MB of code can be scanned at a time.\nScan your project Choose the text, Amazon Q, from the rectangular area at the bottom of the IDE window. A drop-down window will appear at the top from which the user may choose Run Project Scan. "
},
{
	"uri": "//localhost:1313/2-sql-injection/",
	"title": "SQL Injection",
	"tags": [],
	"description": "",
	"content": "SQL injection vulnerability is present within code when user-provided inputs are not sanitized before being used to generate a SQL database query. An attacker can misuse un-trusted input to run query statements that read, modify, or delete database content.\nCopy the following code within your IDE. This code is vulnerable to SQL injection attack as it constructs the SQL query by directly concatenating user input (name) into the query string. An attacker could manipulate the name parameter to alter the SQL command, potentially gaining unauthorized access to other data in the database, corrupting the data, or even dropping tables.\ndef execute_query_noncompliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = \u0026#34; + name + \u0026#34;;\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\r# Noncompliant: user input is used without sanitization.\rcursor.execute(query)\rconnection.commit()\rconnection.close() Click on Amazon Q in the status bar and run Project Scan to see how the SQL Injection Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on “View Details” to learn more: To fix the SQL Injection vulnerability in the provided code, you should use parameterized queries, also known as prepared statements. This method ensures that user inputs are handled safely, preventing attackers from injecting malicious SQL code.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef execute_query_compliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = ?\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\rcursor.execute(query, (name,)) # Use a parameterized query\rconnection.commit()\rconnection.close() Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/3-improper-privilege-management/",
	"title": "Improper Privilege Management",
	"tags": [],
	"description": "",
	"content": "Privilege escalation occurs when a malicious user exploits a bug, design flaw, or configuration error in an application or operating system to gain elevated access to the system. Elevated privileges can be used to delete files, view private information, or install unwanted programs or backdoors.\nCopy the following code within your IDE.\ndef set_user_noncompliant():\rimport os\rroot = 0\r# Noncompliant: the process user is set to root.\ros.setuid(root) Click on Amazon Q in the status bar and run Project Scan to see how the Improper Privilege Management Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Running processes as root should be avoided whenever possible because it can lead to severe security vulnerabilities, including unauthorized access, privilege escalation, and potential system compromise.\nAlways follow the principle of least privilege, meaning that processes should run with the minimum permissions necessary to perform their required tasks. This reduces the risk and potential impact of a security breach.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef set_user_compliant():\rimport os\rroot = 4\r# Compliant: the process user is set to userid 4.\ros.setuid(root) Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/4-path-traversal/",
	"title": "Path Traversal",
	"tags": [],
	"description": "",
	"content": "Constructing path names with unsanitized user input can lead to path traversal attacks (for example, ../../..). This type of attack exploits insufficient security validation/sanitization of user-supplied input file names, allowing attackers to access files or directories that are not intended to be accessible. This can lead to unauthorized access, information disclosure, and even system compromise.\nCopy the following code within your IDE.\ndef verify_file_path_noncompliant():\rfrom flask import request\rfile_path = request.args[\u0026#34;file\u0026#34;]\r# Noncompliant: user input file path is not sanitized.\rfile = open(file_path)\rfile.close() Click on Amazon Q in the status bar and run Project Scan to see how the Path Traversal Vulnerability is detected. The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Path traversal vulnerabilities can be mitigated by sanitizing user input before using it to construct a file path. This approach involves checking if the user-supplied file path is within a predefined list of allowed paths\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef verify_file_path_compliant():\rfrom flask import request\rbase_path = \u0026#34;/var/data/images/\u0026#34;\rfile_path = request.args[\u0026#34;file\u0026#34;]\rallowed_path = [\u0026#34;example_path1\u0026#34;, \u0026#34;example_path2\u0026#34;]\r# Compliant: user input file path is sanitized.\rif file_path in allowed_path:\rfile = open(base_path + file_path)\rfile.close() Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/5-os-command-injection/",
	"title": "Getting started with Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "Constructing operating system or shell commands with unsanitized user input can lead to inadvertently running malicious code. This kind of vulnerability allows an attacker to execute arbitrary commands on the host operating system under the privileges of the vulnerable application. Command injection attacks can lead to a wide range of malicious outcomes, including unauthorized data access, data corruption, denial of service, and complete system compromise.\nCopy the following code within your IDE.\ndef exec_command_noncompliant():\rfrom paramiko import client\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\rcmd = \u0026#34;ping -c 1 %s\u0026#34; % address\rclient = client.SSHClient()\rclient.connect(\u0026#34;ssh.samplehost.com\u0026#34;)\r# Noncompliant: address argument is not sanitized.\rclient.exec_command(cmd) Run Amazon Q Project Scan to see how the OS command injection vulnerability is detected. To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Whenever possible, avoid constructing shell commands with user inputs. Use language-specific APIs or libraries designed to perform the required actions without invoking the shell.\nInput Validation and Sanitization: If you must include user input in a shell command, rigorously validate the input to ensure it conforms to expected formats (e.g., alphanumeric only). Sanitize the input by escaping or removing potentially dangerous characters.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\nfrom paramiko import SSHClient, AutoAddPolicy\rimport os\rimport shlex\rdef exec_command_compliant():\r# Retrieve SSH credentials and server details from environment variables\rssh_host = os.getenv(\u0026#39;SSH_HOST\u0026#39;, \u0026#39;default_host\u0026#39;)\rssh_username = os.getenv(\u0026#39;SSH_USERNAME\u0026#39;, \u0026#39;default_username\u0026#39;)\rssh_password = os.getenv(\u0026#39;SSH_PASSWORD\u0026#39;, \u0026#39;default_password\u0026#39;)\r# Get the address from the request\u0026#39;s query parameters\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\r# Sanitize the address argument to prevent command injection\rsafe_address = shlex.quote(address)\r# Prepare the ping command with the sanitized address\rcmd = f\u0026#34;ping -c 1 {safe_address}\u0026#34;\r# Initialize the SSH client and connect to the remote host\rclient = SSHClient()\rclient.load_system_host_keys()\r# Use environment variables for credentials\rclient.connect(ssh_host, username=ssh_username, password=ssh_password)\r# Execute the command on the remote server\rstdin, stdout, stderr = client.exec_command(cmd)\routput = stdout.read().decode()\r# Close the SSH connection\rclient.close()\r# Return or process the command\u0026#39;s output\rreturn output "
},
{
	"uri": "//localhost:1313/6-aws-credentials-logged/",
	"title": "Getting started with Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "In this vulnerability, unencrypted AWS credentials can be logged which can expose those credentials to an attacker. Encrypt sensitive data, such as credentials, before they are logged to make the code more secure.\nCopy the following code within your IDE.\ndef log_credentials_noncompliant():\rimport boto3\rimport logging\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Noncompliant: credentials are written to the logger.\rlogging.info(\u0026#39;Access key: \u0026#39;, access_key)\rlogging.info(\u0026#39;secret access key: \u0026#39;, secret_key) Run Amazon Q Project Scan to see how the this vulnerability is detected. To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Avoid logging sensitive information such as access keys or secret keys. For AWS resource access management, prefer IAM roles over static access and secret keys, especially for applications running on AWS services like EC2, Lambda, etc. IAM roles provide temporary credentials automatically managed by AWS.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef log_credentials_compliant():\rimport boto3\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Compliant: avoids writing credentials to the logger.\rsession = boto3.Session(\raws_access_key_id=access_key,\raws_secret_access_key=secret_key\r) "
},
{
	"uri": "//localhost:1313/7-conclusion/",
	"title": "Conclution",
	"tags": [],
	"description": "",
	"content": "In this workshop we understood how to use Amazon Q Developer to detect security policy violations and vulnerabilities in your code with static application security testing (SAST), secrets detection, and infrastructure as code (IaC) scanning. Security scans in Amazon Q identify security vulnerabilities and suggest how to improve your code.\nIncorporating security tools like Amazon Q into the development environment, especially within the Integrated Development Environment (IDE), offers significant advantages for maintaining high security and code quality standards. Here are a few:\nReal-Time Detection: By analyzing code in real-time as it\u0026rsquo;s written, developers receive immediate feedback on potential vulnerabilities, coding standards violations, and even simple syntax errors. This instant feedback loop encourages learning and correction on the spot, rather than after the fact.\nEarly Vulnerability Detection: Identifying vulnerabilities early in the development process significantly reduces the costs and effort required to fix them later. Early detection means security issues can often be resolved before the code is merged into the main codebase, much less deployed to production.\nBetter Code Practices: With suggestions on how to improve code or remediate vulnerabilities, developers learn best practices in real-time. This not only improves the security of the current project but also enhances the developer\u0026rsquo;s overall coding skills.\nReduced Remediation Time: Fixing issues in the development phase is significantly cheaper and faster than addressing them in later stages, such as after deployment.\nKeep practising with Amazon Q and leveraging the power of AI to help you improve in your security journey.\nNext Steps Continue your Amazon Q learning journey by exploring these specialized workshop modules:\nAI-Assisted Coding with Amazon Q Troubleshooting and Debugging with Amazon Q Code Transformation and Modernization with Amazon Q Amazon Q Business for Enterprise Users Security Features in Amazon Q Accelerate Mainframe Modernization with Amazon Q Developer Transform Secure Your Code With Amazon Q Developer Building Agentic Workflows on AWS with Amazon Q Building with Generative AI using PartyRock, Bedrock, and Amazon Q Each module provides detailed hands-on experience to help you build production-ready Amazon Q applications.\nCredits Tran Doan Cong Ly - https://www.linkedin.com/in/trandoancongly/\nReferences Amazon Q Developer (User Guide) Getting started with Amazon Q Developer operational investigations Getting Started with Amazon Q Developer "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]