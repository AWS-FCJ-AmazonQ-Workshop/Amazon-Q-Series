[
{
	"uri": "//localhost:1313/vi/1-open-redirect-vulnerability/",
	"title": "Open Redirect Vulnerability",
	"tags": [],
	"description": "",
	"content": "Open Redirect Vulnerability is an security weakness where an attacker could supply a malicious URL as an input, potentially leading users to phishing or malware sites. This is a common security flaw in web applications that can be exploited to conduct phishing attacks or distribute malware.\nFirst, create a folder. Then, create a .py file inside it and paste the code into the file.\nfrom flask import app\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url_noncompliant():\rfrom flask import request, redirect\rendpoint = request.args[\u0026#39;url\u0026#39;]\r# Noncompliant: redirect to a user-supplied URL without sanitization.\rreturn redirect(endpoint) Click on Amazon Q in the status bar and run Project Scan to see how the Open Redirect Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: To fix the open redirect issue in the provided code snippet, you should validate and/or sanitize the URL before performing the redirection. For example, only allow redirects to known, safe domains by checking the user-supplied URL against a whitelist.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\nfrom flask import Flask, request, redirect, url_for\rapp = Flask(__name__)\rALLOWED_HOSTS = [\u0026#39;www.example.com\u0026#39;, \u0026#39;example.org\u0026#39;]\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url():\rfrom urllib.parse import urlparse\r# Retrieve the URL from request arguments and parse it\ruser_url = request.args.get(\u0026#39;url\u0026#39;, \u0026#39;\u0026#39;)\rparsed_url = urlparse(user_url)\r# Check if the URL\u0026#39;s host is in the list of allowed hosts\rif parsed_url.netloc in ALLOWED_HOSTS:\rreturn redirect(user_url)\relse:\r# Redirect to a default page or show an error\rreturn redirect(url_for(\u0026#39;index\u0026#39;)) # Assume \u0026#39;index\u0026#39; is a valid endpoint Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Khả năng quan sát với Amazon ECS",
	"tags": [],
	"description": "",
	"content": "Observability with Amazon ECS Khả năng quan sát là khả năng liên tục tạo và khám phá những thông tin chi tiết hữu ích dựa trên các tín hiệu từ hệ thống đang được theo dõi. Nói cách khác, khả năng quan sát cho phép người dùng hiểu được trạng thái của hệ thống từ các đầu ra bên ngoài của nó và thực hiện các hành động phù hợp. Ba trụ cột của khả năng quan sát là số liệu (metrics), nhật ký (logs) và dấu vết (traces):\nSố liệu (Metrics) Số liệu biểu diễn dữ liệu số được đo lường theo các khoảng thời gian. Chúng tận dụng mô hình hóa và dự đoán toán học để hiểu hành vi của hệ thống ở cả hiện tại và tương lai. Chúng hữu ích để xác định xu hướng và cho phép mô hình hóa và dự đoán toán học. Nhật ký (Logs) Nhật ký bao gồm các bản ghi được đánh dấu thời gian, bất biến, ghi lại các sự kiện rời rạc khi chúng xảy ra theo thời gian. Chúng có giá trị trong việc phát hiện các hành vi mới nổi và khó lường. Chúng đặc biệt hữu ích để khám phá các mô hình hành vi mới nổi và khó lường. Dấu vết (Traces) Dấu vết mô tả một chuỗi các sự kiện phân tán, liên kết với nhau, vạch ra hành trình đầu cuối của một yêu cầu thông qua một hệ thống phân tán. Chúng cung cấp thông tin chi tiết, chẳng hạn như độ trễ, về đường đi của một yêu cầu và cấu trúc của nó. Chúng cung cấp khả năng hiển thị cả đường đi mà một yêu cầu đã đi qua cũng như cấu trúc của một yêu cầu. Tóm lại, chúng ta có thể chia khả năng quan sát thành ba thành phần chính: CloudWatch Metrics, CloudWatch Logs và AWS X-Ray. Cùng nhau, chúng tạo thành một giải pháp khả năng quan sát toàn diện trên AWS, bao gồm giám sát số liệu, quản lý nhật ký và theo dõi phân tán. Các trụ cột này phối hợp với nhau để cung cấp cho người dùng những hiểu biết sâu sắc về hành vi, hiệu suất và độ tin cậy của môi trường và ứng dụng AWS của họ.\n"
},
{
	"uri": "//localhost:1313/vi/2-sql-injection/",
	"title": "SQL Injection",
	"tags": [],
	"description": "",
	"content": "SQL injection vulnerability is present within code when user-provided inputs are not sanitized before being used to generate a SQL database query. An attacker can misuse un-trusted input to run query statements that read, modify, or delete database content.\nCopy the following code within your IDE. This code is vulnerable to SQL injection attack as it constructs the SQL query by directly concatenating user input (name) into the query string. An attacker could manipulate the name parameter to alter the SQL command, potentially gaining unauthorized access to other data in the database, corrupting the data, or even dropping tables.\ndef execute_query_noncompliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = \u0026#34; + name + \u0026#34;;\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\r# Noncompliant: user input is used without sanitization.\rcursor.execute(query)\rconnection.commit()\rconnection.close() Click on Amazon Q in the status bar and run Project Scan to see how the SQL Injection Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on “View Details” to learn more: To fix the SQL Injection vulnerability in the provided code, you should use parameterized queries, also known as prepared statements. This method ensures that user inputs are handled safely, preventing attackers from injecting malicious SQL code.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef execute_query_compliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = ?\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\rcursor.execute(query, (name,)) # Use a parameterized query\rconnection.commit()\rconnection.close() Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/vi/3-improper-privilege-management/",
	"title": "Improper Privilege Management",
	"tags": [],
	"description": "",
	"content": "Privilege escalation occurs when a malicious user exploits a bug, design flaw, or configuration error in an application or operating system to gain elevated access to the system. Elevated privileges can be used to delete files, view private information, or install unwanted programs or backdoors.\nCopy the following code within your IDE.\ndef set_user_noncompliant():\rimport os\rroot = 0\r# Noncompliant: the process user is set to root.\ros.setuid(root) Click on Amazon Q in the status bar and run Project Scan to see how the Improper Privilege Management Vulnerability is detected. Select Review workspace or Review active file The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Running processes as root should be avoided whenever possible because it can lead to severe security vulnerabilities, including unauthorized access, privilege escalation, and potential system compromise.\nAlways follow the principle of least privilege, meaning that processes should run with the minimum permissions necessary to perform their required tasks. This reduces the risk and potential impact of a security breach.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef set_user_compliant():\rimport os\rroot = 4\r# Compliant: the process user is set to userid 4.\ros.setuid(root) Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/vi/4-path-traversal/",
	"title": "Path Traversal",
	"tags": [],
	"description": "",
	"content": "Constructing path names with unsanitized user input can lead to path traversal attacks (for example, ../../..). This type of attack exploits insufficient security validation/sanitization of user-supplied input file names, allowing attackers to access files or directories that are not intended to be accessible. This can lead to unauthorized access, information disclosure, and even system compromise.\nCopy the following code within your IDE.\ndef verify_file_path_noncompliant():\rfrom flask import request\rfile_path = request.args[\u0026#34;file\u0026#34;]\r# Noncompliant: user input file path is not sanitized.\rfile = open(file_path)\rfile.close() Click on Amazon Q in the status bar and run Project Scan to see how the Path Traversal Vulnerability is detected. The following finding will be visible in the status bar To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Path traversal vulnerabilities can be mitigated by sanitizing user input before using it to construct a file path. This approach involves checking if the user-supplied file path is within a predefined list of allowed paths\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef verify_file_path_compliant():\rfrom flask import request\rbase_path = \u0026#34;/var/data/images/\u0026#34;\rfile_path = request.args[\u0026#34;file\u0026#34;]\rallowed_path = [\u0026#34;example_path1\u0026#34;, \u0026#34;example_path2\u0026#34;]\r# Compliant: user input file path is sanitized.\rif file_path in allowed_path:\rfile = open(base_path + file_path)\rfile.close() Try fixing the issue and running the scan again.\n"
},
{
	"uri": "//localhost:1313/vi/5-os-command-injection/",
	"title": "Getting started with Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "Constructing operating system or shell commands with unsanitized user input can lead to inadvertently running malicious code. This kind of vulnerability allows an attacker to execute arbitrary commands on the host operating system under the privileges of the vulnerable application. Command injection attacks can lead to a wide range of malicious outcomes, including unauthorized data access, data corruption, denial of service, and complete system compromise.\nCopy the following code within your IDE.\ndef exec_command_noncompliant():\rfrom paramiko import client\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\rcmd = \u0026#34;ping -c 1 %s\u0026#34; % address\rclient = client.SSHClient()\rclient.connect(\u0026#34;ssh.samplehost.com\u0026#34;)\r# Noncompliant: address argument is not sanitized.\rclient.exec_command(cmd) Run Amazon Q Project Scan to see how the OS command injection vulnerability is detected. To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Whenever possible, avoid constructing shell commands with user inputs. Use language-specific APIs or libraries designed to perform the required actions without invoking the shell.\nInput Validation and Sanitization: If you must include user input in a shell command, rigorously validate the input to ensure it conforms to expected formats (e.g., alphanumeric only). Sanitize the input by escaping or removing potentially dangerous characters.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\nfrom paramiko import SSHClient, AutoAddPolicy\rimport os\rimport shlex\rdef exec_command_compliant():\r# Retrieve SSH credentials and server details from environment variables\rssh_host = os.getenv(\u0026#39;SSH_HOST\u0026#39;, \u0026#39;default_host\u0026#39;)\rssh_username = os.getenv(\u0026#39;SSH_USERNAME\u0026#39;, \u0026#39;default_username\u0026#39;)\rssh_password = os.getenv(\u0026#39;SSH_PASSWORD\u0026#39;, \u0026#39;default_password\u0026#39;)\r# Get the address from the request\u0026#39;s query parameters\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\r# Sanitize the address argument to prevent command injection\rsafe_address = shlex.quote(address)\r# Prepare the ping command with the sanitized address\rcmd = f\u0026#34;ping -c 1 {safe_address}\u0026#34;\r# Initialize the SSH client and connect to the remote host\rclient = SSHClient()\rclient.load_system_host_keys()\r# Use environment variables for credentials\rclient.connect(ssh_host, username=ssh_username, password=ssh_password)\r# Execute the command on the remote server\rstdin, stdout, stderr = client.exec_command(cmd)\routput = stdout.read().decode()\r# Close the SSH connection\rclient.close()\r# Return or process the command\u0026#39;s output\rreturn output "
},
{
	"uri": "//localhost:1313/vi/6-aws-credentials-logged/",
	"title": "Getting started with Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "In this vulnerability, unencrypted AWS credentials can be logged which can expose those credentials to an attacker. Encrypt sensitive data, such as credentials, before they are logged to make the code more secure.\nCopy the following code within your IDE.\ndef log_credentials_noncompliant():\rimport boto3\rimport logging\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Noncompliant: credentials are written to the logger.\rlogging.info(\u0026#39;Access key: \u0026#39;, access_key)\rlogging.info(\u0026#39;secret access key: \u0026#39;, secret_key) Run Amazon Q Project Scan to see how the this vulnerability is detected. To views details of the findings, hold your cursor over the insecure code and click on \u0026ldquo;View Details\u0026rdquo; to learn more: Avoid logging sensitive information such as access keys or secret keys. For AWS resource access management, prefer IAM roles over static access and secret keys, especially for applications running on AWS services like EC2, Lambda, etc. IAM roles provide temporary credentials automatically managed by AWS.\nBelow is an example of how this code can be fixed. Make sure to save the file prior to re-running the scan.\ndef log_credentials_compliant():\rimport boto3\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Compliant: avoids writing credentials to the logger.\rsession = boto3.Session(\raws_access_key_id=access_key,\raws_secret_access_key=secret_key\r) "
},
{
	"uri": "//localhost:1313/vi/7-conclusion/",
	"title": "Conclution",
	"tags": [],
	"description": "",
	"content": "In this workshop we understood how to use Amazon Q Developer to detect security policy violations and vulnerabilities in your code with static application security testing (SAST), secrets detection, and infrastructure as code (IaC) scanning. Security scans in Amazon Q identify security vulnerabilities and suggest how to improve your code.\nIncorporating security tools like Amazon Q into the development environment, especially within the Integrated Development Environment (IDE), offers significant advantages for maintaining high security and code quality standards. Here are a few:\nReal-Time Detection: By analyzing code in real-time as it\u0026rsquo;s written, developers receive immediate feedback on potential vulnerabilities, coding standards violations, and even simple syntax errors. This instant feedback loop encourages learning and correction on the spot, rather than after the fact.\nEarly Vulnerability Detection: Identifying vulnerabilities early in the development process significantly reduces the costs and effort required to fix them later. Early detection means security issues can often be resolved before the code is merged into the main codebase, much less deployed to production.\nBetter Code Practices: With suggestions on how to improve code or remediate vulnerabilities, developers learn best practices in real-time. This not only improves the security of the current project but also enhances the developer\u0026rsquo;s overall coding skills.\nReduced Remediation Time: Fixing issues in the development phase is significantly cheaper and faster than addressing them in later stages, such as after deployment.\nKeep practising with Amazon Q and leveraging the power of AI to help you improve in your security journey.\nNext Steps Continue your Amazon Q learning journey by exploring these specialized workshop modules:\nAI-Assisted Coding with Amazon Q Troubleshooting and Debugging with Amazon Q Code Transformation and Modernization with Amazon Q Amazon Q Business for Enterprise Users Security Features in Amazon Q Accelerate Mainframe Modernization with Amazon Q Developer Transform Secure Your Code With Amazon Q Developer Building Agentic Workflows on AWS with Amazon Q Building with Generative AI using PartyRock, Bedrock, and Amazon Q Each module provides detailed hands-on experience to help you build production-ready Amazon Q applications.\nCredits Tran Doan Cong Ly - https://www.linkedin.com/in/trandoancongly/\nReferences Amazon Q Developer (User Guide) Getting started with Amazon Q Developer operational investigations Getting Started with Amazon Q Developer "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]