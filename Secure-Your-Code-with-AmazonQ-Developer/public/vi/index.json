[
{
	"uri": "//localhost:1313/vi/1-open-redirect-vulnerability/",
	"title": "Lỗ hổng Open Redirect",
	"tags": [],
	"description": "",
	"content": "Lỗ hổng Open Redirect (Chuyển hướng Mở) là một điểm yếu bảo mật, trong đó kẻ tấn công có thể cung cấp một URL độc hại làm đầu vào, có khả năng dẫn người dùng đến các trang web lừa đảo hoặc chứa phần mềm độc hại. Đây là một lỗi bảo mật phổ biến trong các ứng dụng web có thể bị khai thác để thực hiện các cuộc tấn công lừa đảo hoặc phát tán phần mềm độc hại.\nĐầu tiên, tạo một thư mục. Sau đó, tạo một tệp .py bên trong và dán đoạn mã sau vào tệp.\nfrom flask import app\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url_noncompliant():\rfrom flask import request, redirect\rendpoint = request.args[\u0026#39;url\u0026#39;]\r# Noncompliant: redirect to a user-supplied URL without sanitization.\rreturn redirect(endpoint) Nhấp vào Amazon Q trên thanh trạng thái và chạy Project Scan để xem cách phát hiện Lỗ hổng Open Redirect. Chọn Review workspace or Review active file Phát hiện sau sẽ hiển thị trên thanh trạng thái Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào \u0026ldquo;View Details\u0026rdquo; để tìm hiểu thêm: Để khắc phục vấn đề chuyển hướng mở trong đoạn mã được cung cấp, bạn nên xác thực và/hoặc làm sạch URL trước khi thực hiện chuyển hướng. Ví dụ: chỉ cho phép chuyển hướng đến các miền đã biết, an toàn bằng cách kiểm tra URL do người dùng cung cấp với danh sách trắng.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\nfrom flask import Flask, request, redirect, url_for\rapp = Flask(__name__)\rALLOWED_HOSTS = [\u0026#39;www.example.com\u0026#39;, \u0026#39;example.org\u0026#39;]\r@app.route(\u0026#39;/redirect\u0026#39;)\rdef redirect_url():\rfrom urllib.parse import urlparse\r# Retrieve the URL from request arguments and parse it\ruser_url = request.args.get(\u0026#39;url\u0026#39;, \u0026#39;\u0026#39;)\rparsed_url = urlparse(user_url)\r# Check if the URL\u0026#39;s host is in the list of allowed hosts\rif parsed_url.netloc in ALLOWED_HOSTS:\rreturn redirect(user_url)\relse:\r# Redirect to a default page or show an error\rreturn redirect(url_for(\u0026#39;index\u0026#39;)) # Assume \u0026#39;index\u0026#39; is a valid endpoint Thử khắc phục vấn đề và chạy lại quá trình quét.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Bảo Mật Code Của Bạn Với Amazon Q Developer",
	"tags": [],
	"description": "",
	"content": "Bảo Mật Code Của Bạn Với Amazon Q Developer Amazon Q có thể quét codebase của bạn để tìm các lỗ hổng bảo mật và các vấn đề về chất lượng mã nhằm cải thiện trạng thái bảo mật của các ứng dụng của bạn trong suốt chu kỳ phát triển. Bạn có thể bắt đầu quét toàn bộ codebase, phân tích tất cả các tệp trong dự án hoặc không gian làm việc cục bộ của bạn, hoặc bật tính năng tự động quét để đánh giá mã của bạn khi bạn viết.\nĐiều này giúp các ứng dụng của bạn an toàn và có khả năng phục hồi tốt hơn bằng cách làm nổi bật các vấn đề bảo mật như các lỗ hổng cross-site scripting, log injection, quyền truy cập tệp lỏng lẻo, thông tin đăng nhập được mã hóa cứng và hơn thế nữa. Các vấn đề bảo mật được phát hiện càng sớm thì càng ít công việc và nỗ lực cần thiết để khắc phục chúng.\nQuá trình quét được hỗ trợ bởi Bộ phát hiện Bảo mật từ Thư viện Bộ phát hiện Amazon CodeGuru. Khi các chính sách bảo mật được cập nhật và các bộ phát hiện được thêm vào, quá trình quét sẽ tự động tích hợp các bộ phát hiện mới để đảm bảo mã của bạn tuân thủ các chính sách cập nhật nhất.\nAmazon Q Developer phát hiện các vi phạm chính sách bảo mật và các lỗ hổng trong mã của bạn bằng cách kiểm thử bảo mật ứng dụng tĩnh (SAST), phát hiện bí mật và quét cơ sở hạ tầng dưới dạng mã (IaC). Các vấn đề bảo mật được tìm thấy trong quá trình quét sẽ được làm nổi bật trong bảng Problems (Vấn đề) trong VS Code.\nTrong phần này, chúng ta sẽ sử dụng các tính năng Quét Bảo mật của Q Developer để phát hiện mã không an toàn.\nModule này cố ý bao gồm các đoạn mã sẽ kích hoạt các phát hiện quét bảo mật. Các đoạn mã trong module này chỉ nên được sử dụng cho mục đích trình diễn.\nAmazon Q có thể quét toàn bộ codebase của bạn hoặc tự động quét mã của bạn khi bạn viết. Cho mục đích của workshop này, chúng ta sẽ sử dụng quét dựa trên dự án. Có thể quét tối đa 100 MB mã cùng một lúc.\nScan dự án của bạn Chọn chữ Amazon Q từ vùng hình chữ nhật ở dưới cùng cửa sổ IDE. Một cửa sổ thả xuống sẽ xuất hiện ở trên cùng, từ đó người dùng có thể chọn Run Project Scan. "
},
{
	"uri": "//localhost:1313/vi/2-sql-injection/",
	"title": "SQL Injection",
	"tags": [],
	"description": "",
	"content": "Lỗ hổng SQL injection xuất hiện trong mã khi các đầu vào do người dùng cung cấp không được làm sạch trước khi được sử dụng để tạo truy vấn cơ sở dữ liệu SQL. Kẻ tấn công có thể lạm dụng đầu vào không đáng tin cậy để chạy các câu lệnh truy vấn đọc, sửa đổi hoặc xóa nội dung cơ sở dữ liệu.\nSao chép đoạn mã sau vào IDE của bạn. Đoạn mã này dễ bị tấn công SQL injection vì nó xây dựng truy vấn SQL bằng cách nối trực tiếp đầu vào của người dùng (name) vào chuỗi truy vấn. Kẻ tấn công có thể thao túng tham số name để thay đổi lệnh SQL, có khả năng giành quyền truy cập trái phép vào dữ liệu khác trong cơ sở dữ liệu, làm hỏng dữ liệu hoặc thậm chí xóa các bảng.\ndef execute_query_noncompliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = \u0026#34; + name + \u0026#34;;\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\r# Noncompliant: user input is used without sanitization.\rcursor.execute(query)\rconnection.commit()\rconnection.close() Nhấp vào Amazon Q trên thanh trạng thái và chạy Project Scan để xem cách phát hiện Lỗ hổng SQL Injection. Chọn Review workspace or Review active file Phát hiện sau sẽ hiển thị trên thanh trạng thái Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào “View Details” để tìm hiểu thêm: Để khắc phục lỗ hổng SQL Injection trong đoạn mã được cung cấp, bạn nên sử dụng các truy vấn tham số hóa, còn được gọi là prepared statements. Phương pháp này đảm bảo rằng các đầu vào của người dùng được xử lý an toàn, ngăn chặn kẻ tấn công chèn mã SQL độc hại.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\ndef execute_query_compliant(request):\rimport sqlite3\rname = request.GET.get(\u0026#34;name\u0026#34;)\rquery = \u0026#34;SELECT * FROM Users WHERE name = ?\u0026#34;\rwith sqlite3.connect(\u0026#34;example.db\u0026#34;) as connection:\rcursor = connection.cursor()\rcursor.execute(query, (name,)) # Use a parameterized query\rconnection.commit()\rconnection.close() Thử khắc phục vấn đề và chạy lại quá trình quét.\n"
},
{
	"uri": "//localhost:1313/vi/3-improper-privilege-management/",
	"title": "Improper Privilege Management",
	"tags": [],
	"description": "",
	"content": "Leo thang đặc quyền xảy ra khi một người dùng độc hại khai thác một lỗi (bug), lỗ hổng thiết kế hoặc lỗi cấu hình trong một ứng dụng hoặc hệ điều hành để giành được quyền truy cập cao hơn vào hệ thống. Các đặc quyền nâng cao có thể được sử dụng để xóa tệp, xem thông tin riêng tư hoặc cài đặt các chương trình hoặc backdoor không mong muốn.\nSao chép đoạn mã sau vào IDE của bạn.\ndef set_user_noncompliant():\rimport os\rroot = 0\r# Noncompliant: the process user is set to root.\ros.setuid(root) Nhấp vào Amazon Q trên thanh trạng thái và chạy Project Scan để xem cách phát hiện Lỗ hổng Quản lý Đặc quyền Không Đúng cách. Chọn Review workspace or Review active file Phát hiện sau sẽ hiển thị trên thanh trạng thái Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào \u0026ldquo;View Details\u0026rdquo; để tìm hiểu thêm: Nên tránh chạy các tiến trình với quyền root bất cứ khi nào có thể vì nó có thể dẫn đến các lỗ hổng bảo mật nghiêm trọng, bao gồm truy cập trái phép, leo thang đặc quyền và khả năng hệ thống bị xâm nhập.\nLuôn tuân theo nguyên tắc đặc quyền tối thiểu, nghĩa là các tiến trình chỉ nên chạy với các quyền tối thiểu cần thiết để thực hiện các tác vụ được yêu cầu của chúng. Điều này làm giảm rủi ro và tác động tiềm ẩn của một cuộc tấn công bảo mật.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\ndef set_user_compliant():\rimport os\rroot = 4\r# Compliant: the process user is set to userid 4.\ros.setuid(root) Thử khắc phục vấn đề và chạy lại quá trình quét.\n"
},
{
	"uri": "//localhost:1313/vi/4-path-traversal/",
	"title": "Path Traversal",
	"tags": [],
	"description": "",
	"content": "Việc xây dựng tên đường dẫn với đầu vào không được làm sạch của người dùng có thể dẫn đến các cuộc tấn công path traversal (duyệt đường dẫn) (ví dụ: ../../../). Loại tấn công này khai thác việc xác thực/làm sạch không đầy đủ các tên tệp do người dùng cung cấp, cho phép kẻ tấn công truy cập các tệp hoặc thư mục không được phép truy cập. Điều này có thể dẫn đến truy cập trái phép, tiết lộ thông tin và thậm chí xâm nhập hệ thống.\nSao chép đoạn mã sau vào IDE của bạn.\ndef verify_file_path_noncompliant():\rfrom flask import request\rfile_path = request.args[\u0026#34;file\u0026#34;]\r# Noncompliant: user input file path is not sanitized.\rfile = open(file_path)\rfile.close() Nhấp vào Amazon Q trên thanh trạng thái và chạy Project Scan để xem cách phát hiện Lỗ hổng Path Traversal. Phát hiện sau sẽ hiển thị trên thanh trạng thái Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào \u0026ldquo;View Details\u0026rdquo; để tìm hiểu thêm: Các lỗ hổng path traversal có thể được giảm thiểu bằng cách làm sạch đầu vào của người dùng trước khi sử dụng nó để xây dựng đường dẫn tệp. Cách tiếp cận này bao gồm việc kiểm tra xem đường dẫn tệp do người dùng cung cấp có nằm trong danh sách các đường dẫn được phép xác định trước hay không.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\ndef verify_file_path_compliant():\rfrom flask import request\rbase_path = \u0026#34;/var/data/images/\u0026#34;\rfile_path = request.args[\u0026#34;file\u0026#34;]\rallowed_path = [\u0026#34;example_path1\u0026#34;, \u0026#34;example_path2\u0026#34;]\r# Compliant: user input file path is sanitized.\rif file_path in allowed_path:\rfile = open(base_path + file_path)\rfile.close() Thử khắc phục vấn đề và chạy lại quá trình quét.\n"
},
{
	"uri": "//localhost:1313/vi/5-os-command-injection/",
	"title": "OS Command Injection",
	"tags": [],
	"description": "",
	"content": "Việc xây dựng các lệnh hệ điều hành hoặc shell với đầu vào không được làm sạch của người dùng có thể dẫn đến vô tình chạy mã độc hại. Loại lỗ hổng này cho phép kẻ tấn công thực thi các lệnh tùy ý trên hệ điều hành máy chủ với các đặc quyền của ứng dụng dễ bị tấn công. Các cuộc tấn công command injection có thể dẫn đến nhiều kết quả độc hại, bao gồm truy cập dữ liệu trái phép, hỏng dữ liệu, từ chối dịch vụ và xâm nhập hệ thống hoàn toàn.\nSao chép đoạn mã sau vào IDE của bạn.\ndef exec_command_noncompliant():\rfrom paramiko import client\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\rcmd = \u0026#34;ping -c 1 %s\u0026#34; % address\rclient = client.SSHClient()\rclient.connect(\u0026#34;ssh.samplehost.com\u0026#34;)\r# Noncompliant: address argument is not sanitized.\rclient.exec_command(cmd) Chạy Amazon Q Project Scan để xem cách phát hiện lỗ hổng OS command injection. Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào \u0026ldquo;View Details\u0026rdquo; để tìm hiểu thêm: Bất cứ khi nào có thể, hãy tránh xây dựng các lệnh shell với đầu vào của người dùng. Sử dụng các API hoặc thư viện dành riêng cho ngôn ngữ được thiết kế để thực hiện các hành động cần thiết mà không cần gọi shell.\nXác thực và Làm sạch Đầu vào: Nếu bạn phải bao gồm đầu vào của người dùng trong một lệnh shell, hãy xác thực nghiêm ngặt đầu vào để đảm bảo nó tuân thủ các định dạng dự kiến (ví dụ: chỉ chữ và số). Làm sạch đầu vào bằng cách thoát hoặc loại bỏ các ký tự có khả năng gây nguy hiểm.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\nfrom paramiko import SSHClient, AutoAddPolicy\rimport os\rimport shlex\rdef exec_command_compliant():\r# Retrieve SSH credentials and server details from environment variables\rssh_host = os.getenv(\u0026#39;SSH_HOST\u0026#39;, \u0026#39;default_host\u0026#39;)\rssh_username = os.getenv(\u0026#39;SSH_USERNAME\u0026#39;, \u0026#39;default_username\u0026#39;)\rssh_password = os.getenv(\u0026#39;SSH_PASSWORD\u0026#39;, \u0026#39;default_password\u0026#39;)\r# Get the address from the request\u0026#39;s query parameters\rfrom flask import request\raddress = request.args.get(\u0026#34;address\u0026#34;)\r# Sanitize the address argument to prevent command injection\rsafe_address = shlex.quote(address)\r# Prepare the ping command with the sanitized address\rcmd = f\u0026#34;ping -c 1 {safe_address}\u0026#34;\r# Initialize the SSH client and connect to the remote host\rclient = SSHClient()\rclient.load_system_host_keys()\r# Use environment variables for credentials\rclient.connect(ssh_host, username=ssh_username, password=ssh_password)\r# Execute the command on the remote server\rstdin, stdout, stderr = client.exec_command(cmd)\routput = stdout.read().decode()\r# Close the SSH connection\rclient.close()\r# Return or process the command\u0026#39;s output\rreturn output "
},
{
	"uri": "//localhost:1313/vi/6-aws-credentials-logged/",
	"title": "AWS credentials logged",
	"tags": [],
	"description": "",
	"content": "Trong lỗ hổng này, các thông tin đăng nhập AWS chưa được mã hóa có thể bị ghi nhật ký, điều này có thể làm lộ các thông tin đăng nhập đó cho kẻ tấn công. Mã hóa dữ liệu nhạy cảm, chẳng hạn như thông tin đăng nhập, trước khi chúng được ghi nhật ký để làm cho mã an toàn hơn.\nSao chép đoạn mã sau vào IDE của bạn.\ndef log_credentials_noncompliant():\rimport boto3\rimport logging\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Noncompliant: credentials are written to the logger.\rlogging.info(\u0026#39;Access key: \u0026#39;, access_key)\rlogging.info(\u0026#39;secret access key: \u0026#39;, secret_key) Chạy Amazon Q Project Scan để xem cách phát hiện lỗ hổng này. Để xem chi tiết các phát hiện, giữ con trỏ chuột trên đoạn mã không an toàn và nhấp vào \u0026ldquo;View Details\u0026rdquo; để tìm hiểu thêm: Tránh ghi nhật ký thông tin nhạy cảm như khóa truy cập hoặc khóa bí mật. Để quản lý quyền truy cập tài nguyên AWS, hãy ưu tiên sử dụng vai trò IAM hơn là khóa truy cập và khóa bí mật tĩnh, đặc biệt đối với các ứng dụng chạy trên các dịch vụ AWS như EC2, Lambda, v.v. Vai trò IAM cung cấp thông tin đăng nhập tạm thời được AWS tự động quản lý.\nDưới đây là một ví dụ về cách khắc phục đoạn mã này. Đảm bảo lưu tệp trước khi chạy lại quá trình quét.\ndef log_credentials_compliant():\rimport boto3\rsession = boto3.Session()\rcredentials = session.get_credentials()\rcredentials = credentials.get_frozen_credentials()\raccess_key = credentials.access_key\rsecret_key = credentials.secret_key\r# Compliant: avoids writing credentials to the logger.\rsession = boto3.Session(\raws_access_key_id=access_key,\raws_secret_access_key=secret_key\r) "
},
{
	"uri": "//localhost:1313/vi/7-conclusion/",
	"title": "Conclution",
	"tags": [],
	"description": "",
	"content": "Trong workshop này, chúng ta đã tìm hiểu cách sử dụng Amazon Q Developer để phát hiện các vi phạm chính sách bảo mật và các lỗ hổng trong mã của bạn bằng cách kiểm thử bảo mật ứng dụng tĩnh (SAST), phát hiện bí mật và quét cơ sở hạ tầng dưới dạng mã (IaC). Các lần quét bảo mật trong Amazon Q xác định các lỗ hổng bảo mật và đề xuất cách cải thiện mã của bạn.\nViệc tích hợp các công cụ bảo mật như Amazon Q vào môi trường phát triển, đặc biệt là trong Môi trường Phát triển Tích hợp (IDE), mang lại những lợi thế đáng kể để duy trì các tiêu chuẩn bảo mật và chất lượng mã cao. Dưới đây là một vài lợi ích:\nPhát hiện Theo Thời Gian Thực: Bằng cách phân tích mã theo thời gian thực khi nó được viết, các nhà phát triển nhận được phản hồi ngay lập tức về các lỗ hổng tiềm ẩn, các vi phạm tiêu chuẩn mã hóa và thậm chí cả các lỗi cú pháp đơn giản. Vòng phản hồi tức thì này khuyến khích việc học hỏi và sửa chữa tại chỗ, thay vì sau khi sự việc đã xảy ra.\nPhát hiện Lỗ hổng Sớm: Việc xác định các lỗ hổng sớm trong quá trình phát triển giúp giảm đáng kể chi phí và nỗ lực cần thiết để khắc phục chúng sau này. Phát hiện sớm có nghĩa là các vấn đề bảo mật thường có thể được giải quyết trước khi mã được hợp nhất vào codebase chính, chứ chưa nói đến việc triển khai vào sản xuất.\nCải thiện Thông lệ Mã hóa: Với các đề xuất về cách cải thiện mã hoặc khắc phục các lỗ hổng, các nhà phát triển học được các thông lệ tốt nhất theo thời gian thực. Điều này không chỉ cải thiện tính bảo mật của dự án hiện tại mà còn nâng cao kỹ năng viết mã tổng thể của nhà phát triển.\nGiảm Thời gian Khắc phục: Việc khắc phục các vấn đề trong giai đoạn phát triển rẻ hơn và nhanh hơn đáng kể so với việc giải quyết chúng ở các giai đoạn sau, chẳng hạn như sau khi triển khai.\nHãy tiếp tục thực hành với Amazon Q và tận dụng sức mạnh của AI để giúp bạn cải thiện hành trình bảo mật của mình.\nNext Steps Tiếp tục hành trình học tập Amazon Q của bạn bằng cách khám phá các module workshop chuyên biệt sau:\nAI-Assisted Coding with Amazon Q Troubleshooting and Debugging with Amazon Q Code Transformation and Modernization with Amazon Q Amazon Q Business for Enterprise Users Security Features in Amazon Q Accelerate Mainframe Modernization with Amazon Q Developer Transform Secure Your Code With Amazon Q Developer Building Agentic Workflows on AWS with Amazon Q Building with Generative AI using PartyRock, Bedrock, and Amazon Q Mỗi module cung cấp trải nghiệm thực hành chi tiết để giúp bạn xây dựng các ứng dụng Amazon Q sẵn sàng cho sản xuất.\nCredits Tran Doan Cong Ly - https://www.linkedin.com/in/trandoancongly/\nReferences Securing Your Code With Amazon Q Developer "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]